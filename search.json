[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "अप्राकृतिक बुद्धिमत्ता 4 सामाजिक भलाई",
    "section": "",
    "text": "Rendered notebooks for AISG 2025 Assignment 1 :)\nDigvijay Singh Parihar\nGuntas Singh Saran\nHrriday V. Ruparel\nPrathmesh Maharshi"
  },
  {
    "objectID": "posts/zeel/notebook.html",
    "href": "posts/zeel/notebook.html",
    "title": "YOLO Object Detection Tutorial",
    "section": "",
    "text": "import os\nimport numpy as np\nfrom dotenv import load_dotenv\nfrom roboflow import Roboflow\nimport supervision as sv\nfrom ultralytics import YOLO\nfrom PIL import Image\nfrom tqdm.notebook import tqdm\nimport matplotlib.pyplot as plt\n\nload_dotenv()\n\nTrue"
  },
  {
    "objectID": "posts/zeel/notebook.html#download",
    "href": "posts/zeel/notebook.html#download",
    "title": "YOLO Object Detection Tutorial",
    "section": "Download",
    "text": "Download\n\nrf = Roboflow(api_key=os.getenv(\"ROBOFLOW_API_KEY\"))\n\nproject = rf.workspace(\"roboflow-jvuqo\").project(\"poker-cards-fmjio\")\nversion = project.version(4)\ndataset = version.download(\"yolov8\")\n\nloading Roboflow workspace...\nloading Roboflow project...\n\n\n\ndataset.location\n\n'/home/patel_zeel/aisg25_object_detection/poker-cards-4'"
  },
  {
    "objectID": "posts/zeel/notebook.html#exploration",
    "href": "posts/zeel/notebook.html#exploration",
    "title": "YOLO Object Detection Tutorial",
    "section": "Exploration",
    "text": "Exploration\n\n!ls -h {dataset.location}/train/images/*.jpg | head -n 5\n\n/home/patel_zeel/aisg25_object_detection/poker-cards-4/train/images/IMG_20220316_134551_jpg.rf.2934cd1005d243fad04c2b4c8dd86bf0.jpg\n/home/patel_zeel/aisg25_object_detection/poker-cards-4/train/images/IMG_20220316_134551_jpg.rf.43f35e4906dad8dc40ef8f5dc5809b9b.jpg\n/home/patel_zeel/aisg25_object_detection/poker-cards-4/train/images/IMG_20220316_134554_jpg.rf.7176c3883af726bf9a22e3e519567a47.jpg\n/home/patel_zeel/aisg25_object_detection/poker-cards-4/train/images/IMG_20220316_134554_jpg.rf.a0c1ce338490e3a44a2d2ca7de824572.jpg\n/home/patel_zeel/aisg25_object_detection/poker-cards-4/train/images/IMG_20220316_134554_jpg.rf.b92494be3f9059affdeee663029a6f34.jpg\nls: write error: Broken pipe\n\n\n\n!ls -h {dataset.location}/train/labels/*.txt | head -n 5\n\n/home/patel_zeel/aisg25_object_detection/poker-cards-4/train/labels/IMG_20220316_134551_jpg.rf.2934cd1005d243fad04c2b4c8dd86bf0.txt\n/home/patel_zeel/aisg25_object_detection/poker-cards-4/train/labels/IMG_20220316_134551_jpg.rf.43f35e4906dad8dc40ef8f5dc5809b9b.txt\n/home/patel_zeel/aisg25_object_detection/poker-cards-4/train/labels/IMG_20220316_134554_jpg.rf.7176c3883af726bf9a22e3e519567a47.txt\n/home/patel_zeel/aisg25_object_detection/poker-cards-4/train/labels/IMG_20220316_134554_jpg.rf.a0c1ce338490e3a44a2d2ca7de824572.txt\n/home/patel_zeel/aisg25_object_detection/poker-cards-4/train/labels/IMG_20220316_134554_jpg.rf.b92494be3f9059affdeee663029a6f34.txt\nls: write error: Broken pipe\n\n\n\n!cat {dataset.location}/data.yaml\n\nnames:\n- 10 of clubs\n- 10 of diamonds\n- 10 of hearts\n- 10 of spades\n- 2 of clubs\n- 2 of diamonds\n- 2 of hearts\n- 2 of spades\n- 3 of clubs\n- 3 of diamonds\n- 3 of hearts\n- 3 of spades\n- 4 of clubs\n- 4 of diamonds\n- 4 of hearts\n- 4 of spades\n- 5 of clubs\n- 5 of diamonds\n- 5 of hearts\n- 5 of spades\n- 6 of clubs\n- 6 of diamonds\n- 6 of hearts\n- 6 of spades\n- 7 of clubs\n- 7 of diamonds\n- 7 of hearts\n- 7 of spades\n- 8 of clubs\n- 8 of diamonds\n- 8 of hearts\n- 8 of spades\n- 9 of clubs\n- 9 of diamonds\n- 9 of hearts\n- 9 of spades\n- ace of clubs\n- ace of diamonds\n- ace of hearts\n- ace of spades\n- jack  of clubs\n- jack of diamonds\n- jack of hearts\n- jack of spades\n- king of clubs\n- king of diamonds\n- king of hearts\n- king of spades\n- queen of clubs\n- queen of diamonds\n- queen of hearts\n- queen of spades\nnc: 52\nroboflow:\n  license: CC BY 4.0\n  project: poker-cards-fmjio\n  url: https://universe.roboflow.com/roboflow-jvuqo/poker-cards-fmjio/dataset/4\n  version: 4\n  workspace: roboflow-jvuqo\ntest: ../test/images\ntrain: ../train/images\nval: ../valid/images"
  },
  {
    "objectID": "posts/zeel/notebook.html#load-with-supervision",
    "href": "posts/zeel/notebook.html#load-with-supervision",
    "title": "YOLO Object Detection Tutorial",
    "section": "Load with supervision",
    "text": "Load with supervision\n\ntrain_data = sv.DetectionDataset.from_yolo(f\"{dataset.location}/train/images\", f\"{dataset.location}/train/labels\", f\"{dataset.location}/data.yaml\")\nlen(train_data)\n\n811"
  },
  {
    "objectID": "posts/zeel/notebook.html#visualize-a-sample",
    "href": "posts/zeel/notebook.html#visualize-a-sample",
    "title": "YOLO Object Detection Tutorial",
    "section": "Visualize a sample",
    "text": "Visualize a sample\n\nimg_path, img, annotations = train_data[0]\n# Hack till https://github.com/roboflow/supervision/issues/1772 is resolved\nannotations.data['class_name'] = np.array(train_data.classes)[annotations.class_id]\nImage.fromarray(img)\n\n\n\n\n\n\n\n\n\nbox_annotator = sv.BoxAnnotator()\nannotated_img = box_annotator.annotate(img.copy(), annotations)\nImage.fromarray(annotated_img)\n\n\n\n\n\n\n\n\n\nbox_annotator = sv.BoxAnnotator()\nlabel_annotator = sv.LabelAnnotator()\nannotated_img = box_annotator.annotate(img.copy(), annotations)\nannotated_img = label_annotator.annotate(annotated_img, annotations)\nImage.fromarray(annotated_img)"
  },
  {
    "objectID": "posts/data_analysis/analysis.html",
    "href": "posts/data_analysis/analysis.html",
    "title": "Data Exploration and Understanding",
    "section": "",
    "text": "import os\nimport cv2\nimport numpy as np\nimport pandas as pd\nfrom glob import glob\nfrom leafmap import leafmap\nfrom pyproj import Transformer\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nfrom natsort.natsort import natsorted\n\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'"
  },
  {
    "objectID": "posts/data_analysis/analysis.html#textimporting-libraries",
    "href": "posts/data_analysis/analysis.html#textimporting-libraries",
    "title": "Data Exploration and Understanding",
    "section": "",
    "text": "import os\nimport cv2\nimport numpy as np\nimport pandas as pd\nfrom glob import glob\nfrom leafmap import leafmap\nfrom pyproj import Transformer\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nfrom natsort.natsort import natsorted\n\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'"
  },
  {
    "objectID": "posts/data_analysis/analysis.html#texthelper-functions",
    "href": "posts/data_analysis/analysis.html#texthelper-functions",
    "title": "Data Exploration and Understanding",
    "section": "\\(\\text{Helper Functions}\\)",
    "text": "\\(\\text{Helper Functions}\\)\n\ndef display_image(im, label, ax = None):\n    \"\"\"\n    Display an image with bounding boxes and class labels.\n\n    Parameters:\n    im (numpy.ndarray): The image to display.\n    label (list): List of labels for the objects in the image. Each label is a string in the format 'class_id x_center y_center width height'.\n    ax (matplotlib.axes._axes.Axes, optional): The axes on which to display the image. If None, a new figure is created.\n\n    Returns:\n    matplotlib.axes._axes.Axes: The axes with the image and bounding boxes.\n    \"\"\"\n    class_colors = {0: (0, 255, 0), 1: (255, 0, 0), 2: (0, 0, 255)}\n    class_labels = {0: 'Class 0', 1: 'Class 1', 2: 'Class 2'}\n    class_colors_for_legend = {0: (0, 255, 0), 1: (0, 0, 255), 2: (255, 0, 0)}\n    \n    if ax is None:\n        for line in label:\n            line = line.strip().split()\n            class_id, x_center, y_center, width, height = map(float, line)\n            x_center, y_center = int(x_center * im.shape[1]), int(y_center * im.shape[0])\n            width, height = int(width * im.shape[1]), int(height * im.shape[0])\n            \n            x1, y1 = x_center - width // 2, y_center - height // 2\n            x2, y2 = x_center + width // 2, y_center + height // 2\n            color = class_colors[int(class_id)]\n            cv2.rectangle(im, (x1, y1), (x2, y2), color, 2)\n            \n        plt.figure(figsize=(6, 6))\n        plt.imshow(cv2.cvtColor(im, cv2.COLOR_BGR2RGB))\n        plt.axis('off')\n        \n        # Create custom legend handles\n        handles = [mpatches.Patch(color=np.array(color)/255, label=class_labels[class_id]) for class_id, color in class_colors_for_legend.items()]\n        plt.legend(handles=handles, loc='upper right')\n        plt.show()\n        return\n    else:\n        for line in label:\n            line = line.strip().split()\n            class_id, x_center, y_center, width, height = map(float, line)\n            x_center, y_center = int(x_center * im.shape[1]), int(y_center * im.shape[0])\n            width, height = int(width * im.shape[1]), int(height * im.shape[0])\n            \n            x1, y1 = x_center - width // 2, y_center - height // 2\n            x2, y2 = x_center + width // 2, y_center + height // 2\n            color = class_colors[int(class_id)]\n            cv2.rectangle(im, (x1, y1), (x2, y2), color, 2)\n        \n        ax.imshow(cv2.cvtColor(im, cv2.COLOR_BGR2RGB))\n        ax.axis('off')\n        \n        # Create custom legend handles\n        handles = [mpatches.Patch(color=np.array(color)/255, label=class_labels[class_id]) for class_id, color in class_colors_for_legend.items()]\n        ax.legend(handles=handles, loc='upper right')\n    return ax\n\n\ndef extract_bounds(file_name):\n    min_x = file_name.split(\"_\")[5]\n    min_y = file_name.split(\"_\")[7]\n    min_x, min_y = map(float, [min_x, min_y])\n    return [[min_x, min_y], [min_x+416, min_y], [min_x+416, min_y+416], [min_x, min_y+416]]\n\ndef get_lat_long_of_chip(file_name):\n    \"\"\"\n    Get the latitude and longitude of the corners of an image chip.\n\n    Parameters:\n    file_name (str): The name of the file containing the image chip.\n\n    Returns:\n    list: A list of latitude and longitude coordinates for the corners of the image chip.\n    \"\"\"\n    tiles = [  (307670.04, 0.31, 0.0, 5434427.100000001, 0.0, -0.31),\n                (312749.07999999996, 0.31, 0.0, 5403952.860000001, 0.0, -0.31),\n                (312749.07999999996, 0.31, 0.0, 5363320.540000001, 0.0, -0.31)]\n\n    tile_index = int(file_name.split(\"_\")[2])-1\n    bounds = extract_bounds(file_name)\n    lat_long = []\n    for bound in bounds:\n        x, y = bound\n        e = tiles[tile_index][0] + ((x) * tiles[tile_index][1])\n        n = tiles[tile_index][3] + ((y) * tiles[tile_index][-1])\n        transformer = Transformer.from_crs(\"epsg:32633\", \"epsg:4326\", always_xy=True)\n\n        long, lat = transformer.transform(e,n)\n        lat_long.append([lat, long])\n    return lat_long\n\ndef get_lat_long_of_bb(file_name, label, instance_idx):\n    \"\"\"\n    Get the latitude and longitude of the bounding box corners for a specific instance in an image chip.\n\n    Parameters:\n    file_name (str): The name of the file containing the image chip.\n    label (list): List of labels for the objects in the image. Each label is a string in the format 'class_id x_center y_center width height'.\n    instance_idx (int): The index of the instance in the label list for which to get the bounding box coordinates.\n\n    Returns:\n    list: A list of latitude and longitude coordinates for the corners of the bounding box.\n    \"\"\"\n    tiles = [  (307670.04, 0.31, 0.0, 5434427.100000001, 0.0, -0.31),\n                (312749.07999999996, 0.31, 0.0, 5403952.860000001, 0.0, -0.31),\n                (312749.07999999996, 0.31, 0.0, 5363320.540000001, 0.0, -0.31)]\n\n    tile_index = int(file_name.split(\"_\")[2])-1\n    data = label[instance_idx].strip().split()\n    x_center, y_center, width, height = map(float, data[1:])\n    x_center, y_center = x_center * 416, y_center * 416\n    width, height = width * 416, height * 416\n\n    min_x, min_y = extract_bounds(file_name)[0]\n\n    coords = [((x_center + min_x), (y_center + min_y)), \n              ((x_center + min_x) - width / 2, (y_center + min_y) - height / 2), \n              ((x_center + min_x) + width / 2, (y_center + min_y) - height / 2), \n              ((x_center + min_x) + width / 2, (y_center + min_y) + height / 2), \n              ((x_center + min_x) - width / 2, (y_center + min_y) + height / 2)]\n    \n    lat_long = []\n    for coord in coords:\n        x, y = coord\n        e = tiles[tile_index][0] + ((x) * tiles[tile_index][1])\n        n = tiles[tile_index][3] + ((y) * tiles[tile_index][-1])\n        transformer = Transformer.from_crs(\"epsg:32633\", \"epsg:4326\", always_xy=True)\n        long, lat = transformer.transform(e,n)\n        lat_long.append([lat, long])\n    return lat_long"
  },
  {
    "objectID": "posts/data_analysis/analysis.html#textloading-data",
    "href": "posts/data_analysis/analysis.html#textloading-data",
    "title": "Data Exploration and Understanding",
    "section": "\\(\\text{Loading Data}\\)",
    "text": "\\(\\text{Loading Data}\\)\n\nlabels_dir_path = \"./labels/labels_native/\"\nlabel_files = glob(labels_dir_path + \"*.txt\")\nlabel_files = [label_file.split(\"/\")[-1] for label_file in label_files]\nlabel_files = natsorted(label_files)\n\nimages_dir_path = \"./maxar/image_chips/image_chips_native/\"\nimage_files = glob(images_dir_path + \"*.tif\")\nimage_files = [image_file.split(\"/\")[-1] for image_file in image_files]\nimage_files = natsorted(image_files)\n\nprint(\"Number of files: \\nLabels: {}\\nImages: {}\".format(len(label_files), len(image_files)))\n\nNumber of files: \nLabels: 2542\nImages: 2542\n\n\n\nall_labels = []\nfor label_file_path in label_files:\n    with open(os.path.join(labels_dir_path, label_file_path), 'r') as f:\n        all_labels.append(f.readlines())\nf.close()\nlen(all_labels)\n\n2542\n\n\n\nall_images = []\nfor image_file_path in image_files:\n    all_images.append(cv2.imread(os.path.join(images_dir_path, image_file_path)))\nall_images = np.array(all_images)\n\n\nall_images.shape\n\n(2542, 416, 416, 3)\n\n\n\nidx = 761\ndisplay_image(all_images[idx], all_labels[idx])"
  },
  {
    "objectID": "posts/data_analysis/analysis.html#textdata-exploration-and-understanding",
    "href": "posts/data_analysis/analysis.html#textdata-exploration-and-understanding",
    "title": "Data Exploration and Understanding",
    "section": "\\(\\text{Data Exploration and Understanding}\\)",
    "text": "\\(\\text{Data Exploration and Understanding}\\)\n\n\\(\\text{Dataset Statistics}\\)\n\nHow many instances of solar panels are present in the dataset?\nCompute and show the value counts of labels per image. E.g., X images have 0 labels, Y images have 1 label, … and so on.\n\n\n\n\nClass ID\nDescription\nCount\n\n\n\n\n0\nHigh Confidence Detection\n29267\n\n\n1\nModerate Confidence Detection\n130\n\n\n2\nLow Confidence Detection\n228\n\n\n\nTotal\n29635\n\n\n\n\n# How many instances of solar panels are present in the dataset?\n\ntotal_instances = 0 # Here, 'instance' means a single solar panel detection \nfor label in all_labels:\n    total_instances += len(label)\nprint(\"Total number of images: {}\".format(len(all_labels)))\nprint(\"Total instances of solar panels: {}\".format(total_instances))\n\nTotal number of images: 2542\nTotal instances of solar panels: 29625\n\n\n\n# Compute and show the value counts of labels per image. E.g., X images have 0 labels, Y images have 1 label, … and so on.\n\nlabel_counts = [len(label) for label in all_labels]\nlabel_counts = pd.Series(label_counts)\nlabel_counts = pd.DataFrame(label_counts.value_counts(), columns=['count'])\nlabel_counts.reset_index(inplace=True)\nlabel_counts.columns = ['Number of instances per image', 'Number of images']\nlabel_counts\n\n\n\n\n\n\n\n\nNumber of instances per image\nNumber of images\n\n\n\n\n0\n3\n221\n\n\n1\n4\n218\n\n\n2\n5\n217\n\n\n3\n6\n189\n\n\n4\n8\n184\n\n\n...\n...\n...\n\n\n69\n64\n1\n\n\n70\n61\n1\n\n\n71\n56\n1\n\n\n72\n55\n1\n\n\n73\n22\n1\n\n\n\n\n74 rows × 2 columns\n\n\n\n\nlabel_counts.plot(x='Number of instances per image', y='Number of images', kind='bar', figsize=(20, 6), color='skyblue', edgecolor='black')\nplt.show()\n\n\n\n\n\n\n\n\n\n# Number of instances per class\n\nclass_counts = {0: 0, 1: 0, 2: 0}\nfor label in all_labels:\n    for line in label:\n        class_id = int(line.strip().split()[0])\n        class_counts[class_id] += 1\nclass_counts\n\n{0: 29267, 1: 130, 2: 228}\n\n\n\n\n\\(\\text{Calculate the statistics of the area of solar panels in meters}\\)\n\nWhat method was used to compute the area (in meters) for a single instance?\nWhat is the mean area and standard deviation?\nPlot the histogram of areas. What do you observe?\n\n\n# What method was used to compute the area (in meters) for a single instance?\n\nprint(\"\"\"\nThe area of a single instance is computed by multiplying the width and height of the bounding box by the area of a single pixel in squared meters.\n\nArea of a single pixel:                 0.31 m x 0.31 m = 0.0961 m^2/pixel                                      [0.31 meters is the resolution of the image]\nArea of a single instance (approx):     (x_width x 416) x (y_width x 416) x 0.0961 m^2/pixel                    [416 is the size of the image]\n\"\"\")\n\n\nThe area of a single instance is computed by multiplying the width and height of the bounding box by the area of a single pixel in squared meters.\n\nArea of a single pixel:                 0.31 m x 0.31 m = 0.0961 m^2/pixel                                      [0.31 meters is the resolution of the image]\nArea of a single instance (approx):     (x_width x 416) x (y_width x 416) x 0.0961 m^2/pixel                    [416 is the size of the image]\n\n\n\n\n# What is the mean area and standard deviation?\n\nareas = []\nfor label in all_labels:\n    for line in label:\n        class_id, x_center, y_center, width, height = map(float, line.strip().split())\n        areas.append(width * height * 0.0961 * 416**2)\nprint(\"Mean area: {:.2f} m^2\".format(np.mean(areas)))\nprint(\"Standard deviation: {:.2f} m^2\".format(np.std(areas)))\n\nMean area: 191.52 m^2\nStandard deviation: 630.70 m^2\n\n\n\n# Plot the histogram of areas. What do you observe?\n\nplt.figure(figsize=(10, 6))\nplt.hist(areas, bins=50, color='skyblue', edgecolor='black', label='Frequency')\nplt.axvline(x=np.mean(areas), color='red', linestyle='dashed', linewidth=2, label = 'Mean')\nplt.axvline(x=np.percentile(areas, 95), color='green', linestyle='dashed', linewidth=2, label = '95th percentile')\nplt.xlabel('Area (m^2)')\nplt.ylabel('Frequency (log scale)')\nplt.title('Histogram of areas')\nplt.grid(axis='y', alpha=0.75)\nplt.yscale('log')\nplt.legend()\nplt.show()\n\nprint(f\"More than 95% of instances have an area less than {np.percentile(areas, 95):.2f} m^2. There are very few instances with extremely large areas (as large as {max(areas):.2f} m^2)\")\n\n\n\n\n\n\n\n\nMore than 95% of instances have an area less than 540.18 m^2. There are very few instances with extremely large areas (as large as 12177.41 m^2)\n\n\n\n\n\\(\\text{Georeferencing}\\)\n\nFind each bounding box’s center coordinate (longitude, latitude) (Hint: use the information provided in the README file). Explain your method and show the verification with Google Maps Satellite view that your identification is correct.\nVisualize the geolocations using the leafmap library with SATELLITE basemap. [https://leafmap.org/] Where are the clusters located?\n\n\n# Find each bounding box's center coordinate (longitude, latitude) (Hint: use the information provided in the README file). \n# Explain your method and show the verification with Google Maps Satellite view that your identification is correct.\n\nprint(\"\"\"\nMethod:\n1. Extract the tile index and min x & y bounds (x0 & y0) from the label_file's name.\n2. Compute the EPSG:32633 coordinates of the desired chip using min x & y bounds and the tile index from the tile information given in the README file.\n      E = E0 + (x0 * x_res)         [x_rot = 0, E0 -&gt; Easting of tile's upper-left corner]\n      N = N0 + (y0 * y_res)         [y_rot = 0, N0 -&gt; Northing of tile's upper-left corner]\n3. Extract and compute the x_width, y_width, x_center, and y_center of the bounding box (in pixels) from the corresponding instance in all_labels.\n      x_width = width * 416         [416 is the size of the image]\n      y_width = height * 416        [416 is the size of the image]\n      x_center = x_center * 416     [416 is the size of the image]\n      y_center = y_center * 416     [416 is the size of the image]\n4. Compute the coordinates of the bounding box using the chip's EPSG:32633 coordinates.\n      x = E + (x_center * x_res)\n      y = N + (y_center * y_res)\n5. Convert the computed coordinates from EPSG:32633 to latitude and longitude using a coordinate transformer (EPSG:32633 -&gt; EPSG:4326).\n6. Return the computed latitude and longitude coordinates of the bounding box. \n\"\"\")\n\n\nMethod:\n1. Extract the tile index and min x & y bounds (x0 & y0) from the label_file's name.\n2. Compute the EPSG:32633 coordinates of the desired chip using min x & y bounds and the tile index from the tile information given in the README file.\n      E = E0 + (x0 * x_res)         [x_rot = 0, E0 -&gt; Easting of tile's upper-left corner]\n      N = N0 + (y0 * y_res)         [y_rot = 0, N0 -&gt; Northing of tile's upper-left corner]\n3. Extract and compute the x_width, y_width, x_center, and y_center of the bounding box (in pixels) from the corresponding instance in all_labels.\n      x_width = width * 416         [416 is the size of the image]\n      y_width = height * 416        [416 is the size of the image]\n      x_center = x_center * 416     [416 is the size of the image]\n      y_center = y_center * 416     [416 is the size of the image]\n4. Compute the coordinates of the bounding box using the chip's EPSG:32633 coordinates.\n      x = E + (x_center * x_res)\n      y = N + (y_center * y_res)\n5. Convert the computed coordinates from EPSG:32633 to latitude and longitude using a coordinate transformer (EPSG:32633 -&gt; EPSG:4326).\n6. Return the computed latitude and longitude coordinates of the bounding box. \n\n\n\nIMPORTANT:  Due to an unidentified cause, an inconsistent offset is being observed in the following questions. As a result, the bounding boxes estimated by the (lat, long) are not visually appearing to enclose the solar panel instance.\n\nObtaining the coordinates of the desired chip\n\nExample 1\n\nlabel_files[0]\n\n'solarpanels_native_1__x0_0_y0_6845_dxdy_416.txt'\n\n\n\nget_lat_long_of_chip(file_name=label_files[0])\n\n[[49.013634580074424, 12.369630665081079],\n [49.0136747546675, 12.371392421009944],\n [49.0125159047291, 12.371453474625222],\n [49.012475731766365, 12.369691759500945]]\n\n\n  Obtained from Google Earth\n\nnew = cv2.imread('./media/new_chip_ex1.png')\nnew = cv2.cvtColor(new, cv2.COLOR_BGR2RGB)\nold = cv2.imread(os.path.join(images_dir_path, image_files[0]))\nold = cv2.cvtColor(old, cv2.COLOR_BGR2RGB)\n\n\nfig, ax = plt.subplots(1, 2, figsize=(20, 10))\nax[1].imshow(new)\nax[1].set_title('Image from Google Earth')\nax[1].axis('off')\nax[0].imshow(old)\nax[0].set_title('Image from the dataset')\nax[0].axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nExample 2\n\nlabel_files[1000]\n\n'solarpanels_native_2__x0_0_y0_11476_dxdy_416.txt'\n\n\n\nget_lat_long_of_chip(file_name=label_files[1000])\n\n[[48.72842676305991, 12.453623859284367],\n [48.728465488528265, 12.455375746240692],\n [48.72730650416857, 12.455434260621793],\n [48.72726778026977, 12.453682413844513]]\n\n\n  Obtained from Google Earth\n\nnew = cv2.imread('./media/new_chip_ex2.png')\nnew = cv2.cvtColor(new, cv2.COLOR_BGR2RGB)\nold = cv2.imread(os.path.join(images_dir_path, image_files[1000]))\nold = cv2.cvtColor(old, cv2.COLOR_BGR2RGB)\n\n\nfig, ax = plt.subplots(1, 2, figsize=(20, 10))\nax[1].imshow(new)\nax[1].set_title('Image from Google Earth')\nax[1].axis('off')\nax[0].imshow(old)\nax[0].set_title('Image from the dataset')\nax[0].axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nExample 3\n\nlabel_files[2000]\n\n'solarpanels_native_3__x0_7403_y0_13361_dxdy_416.txt'\n\n\n\nget_lat_long_of_chip(file_name=label_files[2000])\n\n[[48.35866815685048, 12.503100376777843],\n [48.35870591676594, 12.504839615313871],\n [48.35754681354012, 12.504896252762075],\n [48.35750905515276, 12.503157053604903]]\n\n\n  Obtained from Google Earth\n\nnew = cv2.imread('./media/new_chip_ex3.png')\nnew = cv2.cvtColor(new, cv2.COLOR_BGR2RGB)\nold = cv2.imread(os.path.join(images_dir_path, image_files[2000]))\nold = cv2.cvtColor(old, cv2.COLOR_BGR2RGB)\n\n\nfig, ax = plt.subplots(1, 2, figsize=(20, 10))\nax[1].imshow(new)\nax[1].set_title('Image from Google Earth')\nax[1].axis('off')\nax[0].imshow(old)\nax[0].set_title('Image from the dataset')\nax[0].axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nObtaining the coordinates of the desired bounding box\n\nExample 1\n\nlabel_files[0], all_labels[0]\n\n('solarpanels_native_1__x0_0_y0_6845_dxdy_416.txt',\n ['0 0.8725961538461539 0.7007211538461539 0.057692307692307696 0.05528846153846154\\n',\n  '0 0.6201923076923077 0.6826923076923077 0.04326923076923077 0.038461538461538464\\n',\n  '0 0.7235576923076924 0.7548076923076924 0.05288461538461539 0.05288461538461539\\n',\n  '0 0.875 0.9350961538461539 0.028846153846153848 0.028846153846153848\\n',\n  '0 0.9158653846153847 0.9591346153846154 0.04326923076923077 0.03365384615384616\\n',\n  '0 0.9627403846153847 0.9963942307692308 0.040865384615384616 0.007211538461538462\\n',\n  '0 0.3245192307692308 0.9663461538461539 0.057692307692307696 0.0625\\n',\n  '0 0.6586538461538461 0.7223557692307693 0.038461538461538464 0.03125\\n'])\n\n\n\nget_lat_long_of_chip(file_name=label_files[0])\n\n[[49.013634580074424, 12.369630665081079],\n [49.0136747546675, 12.371392421009944],\n [49.0125159047291, 12.371453474625222],\n [49.012475731766365, 12.369691759500945]]\n\n\n\nget_lat_long_of_bb(file_name=label_files[0], label=all_labels[0], instance_idx=1)\n\n[[49.01286836172854, 12.370764983932983],\n [49.01288977821848, 12.370725695204499],\n [49.012891516355644, 12.370801923877265],\n [49.012846945224595, 12.370804272627897],\n [49.01284520709013, 12.370728044023037]]\n\n\n  Obtained from Google Earth\n\nnew = cv2.imread('./media/bb_ex1.png')\nnew = cv2.cvtColor(new, cv2.COLOR_BGR2RGB)\n\n\nx_center, y_center, width, height = map(float, all_labels[0][1].strip().split(\" \")[1:])\nx_center, y_center = x_center * 416, y_center*416\nfig, ax = plt.subplots(1, 2, figsize=(20, 10))\ndisplay_image(all_images[0], all_labels[0], ax=ax[0])\nax[0].set_title('Image from the dataset')\nax[0].scatter(x_center, y_center, c='red', s=10, marker='x', label='Center of the bounding box')\nax[1].imshow(new)\nax[1].set_title('Image from Google Earth')\nax[1].axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nExample 2\n\nlabel_files[1000], all_labels[1000]\n\n('solarpanels_native_2__x0_0_y0_11476_dxdy_416.txt',\n ['0 0.3665865384615385 0.22235576923076925 0.1466346153846154 0.14182692307692307\\n',\n  '0 0.29927884615384615 0.296875 0.14182692307692307 0.14182692307692307\\n',\n  '0 0.875 0.028846153846153848 0.25 0.057692307692307696\\n',\n  '0 0.9182692307692308 0.29086538461538464 0.16346153846153846 0.19230769230769232\\n',\n  '0 0.8713942307692308 0.31490384615384615 0.1514423076923077 0.17307692307692307\\n',\n  '0 0.23076923076923078 0.3737980769230769 0.13461538461538464 0.14182692307692307\\n',\n  '0 0.3545673076923077 0.530048076923077 0.6225961538461539 0.6129807692307693\\n',\n  '0 0.7055288461538461 0.6430288461538461 0.23317307692307693 0.21875\\n',\n  '0 0.764423076923077 0.6983173076923077 0.21634615384615385 0.19951923076923078\\n',\n  '0 0.6033653846153847 0.8798076923076924 0.22115384615384617 0.22115384615384617\\n',\n  '0 0.46274038461538464 0.9603365384615385 0.19951923076923078 0.07932692307692309\\n',\n  '0 0.44591346153846156 0.8870192307692308 0.28125 0.22596153846153846\\n',\n  '0 0.4375 0.6262019230769231 0.04807692307692308 0.021634615384615384\\n',\n  '0 0.4338942307692308 0.6574519230769231 0.09855769230769232 0.026442307692307696\\n',\n  '0 0.4134615384615385 0.6838942307692308 0.1201923076923077 0.021634615384615384\\n',\n  '0 0.37980769230769235 0.7139423076923077 0.1201923076923077 0.02403846153846154\\n',\n  '0 0.3197115384615385 0.7740384615384616 0.125 0.02403846153846154\\n',\n  '0 0.35216346153846156 0.7427884615384616 0.12259615384615385 0.02403846153846154\\n',\n  '0 0.2932692307692308 0.8028846153846154 0.11538461538461539 0.02403846153846154\\n',\n  '0 0.2620192307692308 0.828125 0.1201923076923077 0.021634615384615384\\n',\n  '0 0.25961538461538464 0.8569711538461539 0.057692307692307696 0.021634615384615384\\n',\n  '0 0.49399038461538464 0.6995192307692308 0.05528846153846154 0.02403846153846154\\n',\n  '0 0.4987980769230769 0.7211538461538461 0.10336538461538462 0.03365384615384616\\n',\n  '0 0.48557692307692313 0.7427884615384616 0.10096153846153846 0.028846153846153848\\n',\n  '0 0.46274038461538464 0.7584134615384616 0.10817307692307693 0.03125\\n',\n  '0 0.4399038461538462 0.7764423076923077 0.11057692307692309 0.028846153846153848\\n',\n  '0 0.4278846153846154 0.7908653846153847 0.10576923076923078 0.03365384615384616\\n',\n  '0 0.4098557692307693 0.811298076923077 0.10817307692307693 0.03125\\n',\n  '0 0.3918269230769231 0.826923076923077 0.09615384615384616 0.028846153846153848\\n',\n  '0 0.3762019230769231 0.8473557692307693 0.10817307692307693 0.026442307692307696\\n',\n  '0 0.35216346153846156 0.8641826923076924 0.11298076923076923 0.03125\\n',\n  '0 0.3293269230769231 0.8810096153846154 0.11057692307692309 0.026442307692307696\\n',\n  '0 0.3185096153846154 0.921875 0.06490384615384616 0.021634615384615384\\n',\n  '0 0.3185096153846154 0.9447115384615385 0.03605769230769231 0.019230769230769232\\n',\n  '0 0.3185096153846154 0.9014423076923077 0.10336538461538462 0.028846153846153848\\n'])\n\n\n\nget_lat_long_of_chip(file_name=label_files[1000])\n\n[[48.72842676305991, 12.453623859284367],\n [48.728465488528265, 12.455375746240692],\n [48.72730650416857, 12.455434260621793],\n [48.72726778026977, 12.453682413844513]]\n\n\n\nget_lat_long_of_bb(file_name=label_files[1000], label=all_labels[1000], instance_idx=6)\n\n[[48.72782618003159, 12.454276050344484],\n [48.72816933972369, 12.453712752265622],\n [48.72819345224244, 12.454803464416429],\n [48.72748301743422, 12.454839340767492],\n [48.72745890551453, 12.453748643950552]]\n\n\n  Obtained from Google Earth\n\nnew = cv2.imread('./media/bb_ex2.png')\nnew = cv2.cvtColor(new, cv2.COLOR_BGR2RGB)\n\n\nx_center, y_center, width, height = map(float, all_labels[1000][6].strip().split(\" \")[1:])\nx_center, y_center = x_center * 416, y_center*416\nfig, ax = plt.subplots(1, 2, figsize=(20, 10))\ndisplay_image(all_images[1000], all_labels[1000], ax=ax[0])\nax[0].set_title('Image from the dataset')\nax[0].scatter(x_center, y_center, c='red', s=10, marker='x', label='Center of the bounding box')\nax[1].imshow(new)\nax[1].set_title('Image from Google Earth')\nax[1].axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nExample 3\n\nlabel_files[2000], all_labels[2000]\n\n('solarpanels_native_3__x0_7403_y0_13361_dxdy_416.txt',\n ['0 0.40625 0.018028846153846156 0.04326923076923077 0.03605769230769231\\n',\n  '0 0.359375 0.3774038461538462 0.026442307692307696 0.02403846153846154\\n'])\n\n\n\nget_lat_long_of_chip(file_name=label_files[2000])\n\n[[48.35866815685048, 12.503100376777843],\n [48.35870591676594, 12.504839615313871],\n [48.35754681354012, 12.504896252762075],\n [48.35750905515276, 12.503157053604903]]\n\n\n\nget_lat_long_of_bb(file_name=label_files[2000], label=all_labels[2000], instance_idx=1)\n\n[[48.358244280231766, 12.503746800346855],\n [48.358257712475286, 12.5037231247565],\n [48.35825871101753, 12.503769113843202],\n [48.3582308479831, 12.503770475924807],\n [48.35822984944184, 12.503724486863135]]\n\n\n  Obtained from Google Earth\n\nnew = cv2.imread('./media/bb_ex3.png')\nnew = cv2.cvtColor(new, cv2.COLOR_BGR2RGB)\n\n\nx_center, y_center, width, height = map(float, all_labels[2000][1].strip().split(\" \")[1:])\nx_center, y_center = x_center * 416, y_center*416\nfig, ax = plt.subplots(1, 2, figsize=(20, 10))\ndisplay_image(all_images[2000], all_labels[2000], ax=ax[0])\nax[0].set_title('Image from the dataset')\nax[0].scatter(x_center, y_center, c='red', s=10, marker='x', label='Center of the bounding box')\nax[1].imshow(new)\nax[1].set_title('Image from Google Earth')\nax[1].axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nLeafmap Georeferencing\n\nm = leafmap.Map()\nm.add_basemap('Google Hybrid', visible = True)\nm.add_markers(markers = get_lat_long_of_bb(file_name=label_files[0], label=all_labels[0], instance_idx=1), x='lon', y='lat', radius=10, popup=None, font_size=2, stroke=True, color='#0033FF', weight=2, fill=True, fill_color=None, fill_opacity=0.2, opacity=1.0, shape='circle')\nm.add_markers(markers = get_lat_long_of_bb(file_name=label_files[1000], label=all_labels[1000], instance_idx=6), x='lon', y='lat', radius=10, popup=None, font_size=2, stroke=True, color='#0033FF', weight=2, fill=True, fill_color=None, fill_opacity=0.2, opacity=1.0, shape='circle')\nm.add_markers(markers = get_lat_long_of_bb(file_name=label_files[2000], label=all_labels[2000], instance_idx=1), x='lon', y='lat', radius=10, popup=None, font_size=2, stroke=True, color='#0033FF', weight=2, fill=True, fill_color=None, fill_opacity=0.2, opacity=1.0, shape='circle')\nm\n\n\n\n\nAs one can observe, the clusters are located near Munich, Germany."
  },
  {
    "objectID": "posts/split/data.html",
    "href": "posts/split/data.html",
    "title": "Dataset Split & Exploration",
    "section": "",
    "text": "import os\nimport shutil\nimport matplotlib.pyplot as plt\nimport random\nimport pandas as pd\nfrom collections import Counter\nimport cv2\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\nimages_dir = \"./data/images\"\nlabels_dir = \"./data/labels\"\nimages_base = set([f.split('.')[0] for f in os.listdir(images_dir)])\nlabels_base = set([f.split('.')[0] for f in os.listdir(labels_dir)])\n\nintersection = images_base.intersection(labels_base)\nuncommon_files = images_base.symmetric_difference(labels_base)\n\nimages = [f for f in os.listdir(images_dir) if f.split('.')[0] in intersection]\nlabels = [f for f in os.listdir(labels_dir) if f.split('.')[0] in intersection]\n\nimages_ = [f.split('.')[0] for f in sorted(images)]\nlabels_ = [f.split('.')[0] for f in sorted(labels)]\ndata = []\nfor img, lbl in zip(images_, labels_):\n    with open(os.path.join(labels_dir, lbl + \".txt\"), 'r') as f:\n        class_ids = [line.split()[0] for line in f]\n    with open(os.path.join(labels_dir, lbl + \".txt\"), 'r') as f:\n        str = f.read()\n        \n    if class_ids:\n        class_ids = Counter(class_ids)\n        data.append((img, str, class_ids['0'], class_ids['1'], class_ids['2']))\n\ndf = pd.DataFrame(data, columns=['image', 'label', 'Tile0', 'Tile1', 'Tile2'])\ndf\n\n\n\n\n\n\n\n\nimage\nlabel\nTile0\nTile1\nTile2\n\n\n\n\n0\nsolarpanels_native_1__x0_0_y0_6845_dxdy_416\n0 0.8725961538461539 0.7007211538461539 0.0576...\n8\n0\n0\n\n\n1\nsolarpanels_native_1__x0_0_y0_6963_dxdy_416\n0 0.8725961538461539 0.4170673076923077 0.0576...\n12\n0\n1\n\n\n2\nsolarpanels_native_1__x0_0_y0_7119_dxdy_416\n0 0.8725961538461539 0.042067307692307696 0.05...\n17\n0\n1\n\n\n3\nsolarpanels_native_1__x0_0_y0_7229_dxdy_416\n0 0.875 0.013221153846153848 0.028846153846153...\n14\n0\n1\n\n\n4\nsolarpanels_native_1__x0_0_y0_7230_dxdy_416\n0 0.875 0.01201923076923077 0.0288461538461538...\n14\n0\n1\n\n\n...\n...\n...\n...\n...\n...\n\n\n2537\nsolarpanels_native_3__x0_9952_y0_11824_dxdy_416\n0 0.7524038461538461 0.34615384615384615 0.048...\n5\n0\n0\n\n\n2538\nsolarpanels_native_3__x0_9965_y0_11241_dxdy_416\n0 0.9771634615384616 0.2403846153846154 0.0360...\n3\n0\n0\n\n\n2539\nsolarpanels_native_3__x0_9972_y0_12567_dxdy_416\n0 0.4074519230769231 0.6490384615384616 0.1658...\n2\n0\n0\n\n\n2540\nsolarpanels_native_3__x0_9979_y0_10637_dxdy_416\n0 0.30649038461538464 0.6598557692307693 0.074...\n5\n0\n0\n\n\n2541\nsolarpanels_native_3__x0_9990_y0_9864_dxdy_416\n0 0.45072115384615385 0.5913461538461539 0.127...\n16\n0\n0\n\n\n\n\n2542 rows × 5 columns\nprint(\"Original Dataset:\\n\", df['Tile0'].sum(), df['Tile1'].sum(), df['Tile2'].sum())\n\nOriginal Dataset:\n 29267 130 228"
  },
  {
    "objectID": "posts/split/data.html#some-play-with-the-data",
    "href": "posts/split/data.html#some-play-with-the-data",
    "title": "Dataset Split & Exploration",
    "section": "Some play with the data",
    "text": "Some play with the data\n\ndf[df['Tile2'] == df['Tile2'].max()]\n\n\n\n\n\n\n\n\nimage\nlabel\nTile0\nTile1\nTile2\n\n\n\n\n857\nsolarpanels_native_1__x0_8565_y0_11093_dxdy_416\n2 0.671875 0.3137019230769231 0.08894230769230...\n0\n0\n9\n\n\n860\nsolarpanels_native_1__x0_8573_y0_11090_dxdy_416\n2 0.6526442307692308 0.32091346153846156 0.088...\n0\n0\n9\n\n\n862\nsolarpanels_native_1__x0_8582_y0_11150_dxdy_416\n2 0.6310096153846154 0.17668269230769232 0.088...\n0\n0\n9\n\n\n865\nsolarpanels_native_1__x0_8596_y0_11097_dxdy_416\n2 0.5973557692307693 0.3040865384615385 0.0889...\n0\n0\n9\n\n\n871\nsolarpanels_native_1__x0_8623_y0_10945_dxdy_416\n2 0.5324519230769231 0.6694711538461539 0.0889...\n0\n0\n9\n\n\n872\nsolarpanels_native_1__x0_8628_y0_10957_dxdy_416\n2 0.5204326923076923 0.640625 0.08894230769230...\n0\n0\n9\n\n\n874\nsolarpanels_native_1__x0_8635_y0_10963_dxdy_416\n2 0.5036057692307693 0.6262019230769231 0.0889...\n0\n0\n9\n\n\n877\nsolarpanels_native_1__x0_8664_y0_11014_dxdy_416\n2 0.4338942307692308 0.5036057692307693 0.0889...\n0\n0\n9\n\n\n878\nsolarpanels_native_1__x0_8670_y0_11147_dxdy_416\n2 0.41947115384615385 0.18389423076923078 0.08...\n0\n0\n9\n\n\n\n\n\n\n\n\ndf[df['Tile1'] == df['Tile1'].max()]\n\n\n\n\n\n\n\n\nimage\nlabel\nTile0\nTile1\nTile2\n\n\n\n\n1118\nsolarpanels_native_2__x0_14692_y0_14213_dxdy_416\n1 0.670673076923077 0.4278846153846154 0.10096...\n0\n2\n0\n\n\n1119\nsolarpanels_native_2__x0_14813_y0_14131_dxdy_416\n1 0.37980769230769235 0.625 0.1009615384615384...\n0\n2\n0\n\n\n1334\nsolarpanels_native_2__x0_5176_y0_6131_dxdy_416\n1 0.9903846153846154 0.43028846153846156 0.019...\n4\n2\n0\n\n\n1335\nsolarpanels_native_2__x0_5184_y0_6305_dxdy_416\n1 0.9807692307692308 0.05528846153846154 0.038...\n5\n2\n0\n\n\n1336\nsolarpanels_native_2__x0_5187_y0_6039_dxdy_416\n1 0.9771634615384616 0.6514423076923077 0.0456...\n9\n2\n0\n\n\n1347\nsolarpanels_native_2__x0_5369_y0_6108_dxdy_416\n0 0.8653846153846154 0.18629807692307693 0.038...\n2\n2\n0\n\n\n1353\nsolarpanels_native_2__x0_5426_y0_6012_dxdy_416\n0 0.7283653846153847 0.4170673076923077 0.0384...\n1\n2\n0\n\n\n1361\nsolarpanels_native_2__x0_5549_y0_6002_dxdy_416\n0 0.9375 0.7560096153846154 0.0336538461538461...\n2\n2\n0\n\n\n1363\nsolarpanels_native_2__x0_5588_y0_6163_dxdy_416\n0 0.84375 0.36899038461538464 0.03365384615384...\n4\n2\n0\n\n\n1368\nsolarpanels_native_2__x0_5619_y0_5655_dxdy_416\n0 0.24639423076923078 0.41466346153846156 0.10...\n13\n2\n0\n\n\n1373\nsolarpanels_native_2__x0_5643_y0_5508_dxdy_416\n0 0.34615384615384615 0.04807692307692308 0.22...\n15\n2\n0\n\n\n1374\nsolarpanels_native_2__x0_5644_y0_5516_dxdy_416\n0 0.34375 0.038461538461538464 0.2211538461538...\n15\n2\n0\n\n\n1387\nsolarpanels_native_2__x0_5736_y0_5488_dxdy_416\n0 0.12259615384615385 0.07211538461538462 0.22...\n14\n2\n0\n\n\n1389\nsolarpanels_native_2__x0_5755_y0_5511_dxdy_416\n0 0.09375 0.04447115384615385 0.1875 0.0889423...\n15\n2\n0\n\n\n1390\nsolarpanels_native_2__x0_5772_y0_5608_dxdy_416\n0 0.03365384615384616 0.7596153846153847 0.052...\n12\n2\n0\n\n\n1393\nsolarpanels_native_2__x0_5795_y0_5600_dxdy_416\n0 0.3004807692307693 0.14302884615384617 0.125...\n11\n2\n0\n\n\n1394\nsolarpanels_native_2__x0_5805_y0_5391_dxdy_416\n0 0.014423076923076924 0.08052884615384616 0.0...\n13\n2\n0\n\n\n1396\nsolarpanels_native_2__x0_5816_y0_5494_dxdy_416\n0 0.020432692307692308 0.06490384615384616 0.0...\n12\n2\n0\n\n\n1397\nsolarpanels_native_2__x0_5817_y0_5587_dxdy_416\n0 0.24759615384615385 0.17427884615384617 0.12...\n12\n2\n0\n\n\n1399\nsolarpanels_native_2__x0_5828_y0_5677_dxdy_416\n0 0.23918269230769232 0.04447115384615385 0.12...\n9\n2\n0\n\n\n1400\nsolarpanels_native_2__x0_5859_y0_5433_dxdy_416\n0 0.1466346153846154 0.5444711538461539 0.125 ...\n10\n2\n0\n\n\n1434\nsolarpanels_native_2__x0_6815_y0_9816_dxdy_416\n0 0.8257211538461539 0.3293269230769231 0.1418...\n3\n2\n0\n\n\n1438\nsolarpanels_native_2__x0_6876_y0_9926_dxdy_416\n0 0.6790865384615385 0.06730769230769232 0.141...\n5\n2\n0\n\n\n1439\nsolarpanels_native_2__x0_6880_y0_9736_dxdy_416\n0 0.6694711538461539 0.5216346153846154 0.1418...\n4\n2\n0\n\n\n1443\nsolarpanels_native_2__x0_6975_y0_10016_dxdy_416\n0 0.7716346153846154 0.028846153846153848 0.04...\n4\n2\n0\n\n\n1445\nsolarpanels_native_2__x0_7013_y0_9828_dxdy_416\n0 0.3497596153846154 0.3004807692307693 0.1418...\n5\n2\n0\n\n\n1446\nsolarpanels_native_2__x0_7046_y0_9851_dxdy_416\n0 0.27043269230769235 0.2451923076923077 0.141...\n5\n2\n0\n\n\n1447\nsolarpanels_native_2__x0_7062_y0_9845_dxdy_416\n0 0.23197115384615385 0.25961538461538464 0.14...\n5\n2\n0\n\n\n1493\nsolarpanels_native_2__x0_8277_y0_3127_dxdy_416\n0 0.48197115384615385 0.48557692307692313 0.04...\n3\n2\n0\n\n\n1495\nsolarpanels_native_2__x0_8319_y0_3069_dxdy_416\n0 0.3810096153846154 0.625 0.04086538461538461...\n3\n2\n0\n\n\n1503\nsolarpanels_native_2__x0_8416_y0_3053_dxdy_416\n0 0.9627403846153847 0.054086538461538464 0.07...\n4\n2\n0\n\n\n1506\nsolarpanels_native_2__x0_8446_y0_2935_dxdy_416\n0 0.9266826923076924 0.33774038461538464 0.146...\n4\n2\n0\n\n\n1511\nsolarpanels_native_2__x0_8478_y0_3018_dxdy_416\n0 0.8882211538461539 0.13822115384615385 0.223...\n4\n2\n0\n\n\n1528\nsolarpanels_native_2__x0_8590_y0_2900_dxdy_416\n0 0.6225961538461539 0.421875 0.23076923076923...\n2\n2\n0\n\n\n1586\nsolarpanels_native_2__x0_9516_y0_2520_dxdy_416\n0 0.49278846153846156 0.3870192307692308 0.067...\n3\n2\n0\n\n\n1597\nsolarpanels_native_2__x0_9606_y0_2546_dxdy_416\n0 0.2764423076923077 0.3245192307692308 0.0673...\n4\n2\n0\n\n\n1603\nsolarpanels_native_2__x0_9656_y0_2596_dxdy_416\n0 0.15625 0.2043269230769231 0.067307692307692...\n5\n2\n0\n\n\n1606\nsolarpanels_native_2__x0_9705_y0_2594_dxdy_416\n0 0.038461538461538464 0.2091346153846154 0.06...\n5\n2\n0\n\n\n1613\nsolarpanels_native_2__x0_9772_y0_2559_dxdy_416\n0 0.4483173076923077 0.42307692307692313 0.137...\n1\n2\n0\n\n\n2177\nsolarpanels_native_3__x0_6102_y0_13284_dxdy_416\n0 0.12379807692307693 0.01682692307692308 0.03...\n7\n2\n0\n\n\n2179\nsolarpanels_native_3__x0_6137_y0_13322_dxdy_416\n0 0.90625 0.10817307692307693 0.1875 0.2163461...\n4\n2\n0\n\n\n2182\nsolarpanels_native_3__x0_6165_y0_13495_dxdy_416\n1 0.655048076923077 0.3557692307692308 0.25240...\n3\n2\n0\n\n\n2185\nsolarpanels_native_3__x0_6200_y0_13369_dxdy_416\n0 0.828125 0.05168269230769231 0.3341346153846...\n4\n2\n0\n\n\n\n\n\n\n\n\ndf[(df['Tile0'] &gt; 0) & (df['Tile1'] &gt; 0) & (df['Tile2'] &gt; 0)]\n\n\n\n\n\n\n\n\nimage\nlabel\nTile0\nTile1\nTile2\n\n\n\n\n778\nsolarpanels_native_1__x0_8158_y0_9952_dxdy_416\n0 0.020432692307692308 0.8317307692307693 0.04...\n4\n1\n1\n\n\n796\nsolarpanels_native_1__x0_8233_y0_9890_dxdy_416\n2 0.375 0.6117788461538461 0.10096153846153846...\n4\n1\n1\n\n\n819\nsolarpanels_native_1__x0_8356_y0_9984_dxdy_416\n2 0.07932692307692309 0.3858173076923077 0.100...\n4\n1\n1\n\n\n821\nsolarpanels_native_1__x0_8366_y0_9849_dxdy_416\n2 0.05528846153846154 0.7103365384615385 0.100...\n6\n1\n1\n\n\n822\nsolarpanels_native_1__x0_8385_y0_9752_dxdy_416\n2 0.030048076923076924 0.9435096153846154 0.06...\n4\n1\n1\n\n\n825\nsolarpanels_native_1__x0_8393_y0_10108_dxdy_416\n2 0.020432692307692308 0.08774038461538462 0.0...\n6\n1\n1\n\n\n2208\nsolarpanels_native_3__x0_6464_y0_13626_dxdy_416\n0 0.9639423076923077 0.11538461538461539 0.038...\n2\n1\n1\n\n\n\n\n\n\n\n\ndf[df[\"Tile0\"] == df[\"Tile0\"].max()]\n\n\n\n\n\n\n\n\nimage\nlabel\nTile0\nTile1\nTile2\n\n\n\n\n1450\nsolarpanels_native_2__x0_714_y0_10614_dxdy_416\n0 0.7379807692307693 0.007211538461538462 0.26...\n78\n0\n0"
  },
  {
    "objectID": "posts/split/data.html#annotations-from-the-dataset",
    "href": "posts/split/data.html#annotations-from-the-dataset",
    "title": "Dataset Split & Exploration",
    "section": "Annotations from the dataset",
    "text": "Annotations from the dataset\n\ndef give_image(filename):\n    fileIm = f\"./data/images/{filename}.tif\"\n    fileLb = f\"./data/labels/{filename}.txt\"\n    \n    im = cv2.imread(fileIm)\n    \n    with open(fileLb, 'r') as f:\n        lines = f.readlines()\n        \n    for line in lines:\n        line = line.strip().split()\n        class_id, x_center, y_center, width, height = map(float, line)\n        x_center, y_center = int(x_center * im.shape[1]), int(y_center * im.shape[0])\n        width, height = int(width * im.shape[1]), int(height * im.shape[0])\n        \n        x1, y1 = x_center - width // 2, y_center - height // 2\n        x2, y2 = x_center + width // 2, y_center + height // 2\n\n        if class_id == 0:\n            cv2.rectangle(im, (x1, y1), (x2, y2), (0, 255, 0), 2)\n        elif class_id == 1:\n            cv2.rectangle(im, (x1, y1), (x2, y2), (255, 0, 0), 2)\n        elif class_id == 2:\n            cv2.rectangle(im, (x1, y1), (x2, y2), (0, 0, 255), 2)\n        \n    plt.figure(figsize=(6, 6))\n    plt.imshow(cv2.cvtColor(im, cv2.COLOR_BGR2RGB))\n    plt.axis('off')\n    plt.show()\n\n\ngive_image(images_[878])\ngive_image(images_[819])\ngive_image(images_[1450])"
  },
  {
    "objectID": "posts/iou/part2.html",
    "href": "posts/iou/part2.html",
    "title": "Implementing Average Precision AP50",
    "section": "",
    "text": "import numpy as np\nfrom shapely.geometry import box\nimport random\nimport matplotlib.pyplot as plt\nimport supervision as sv\nfrom matplotlib.patches import Rectangle\n\n\ndef compute_iou_shapely_batch(boxes1, boxes2):\n    \"\"\"\n    Compute IoU between two sets of boxes in [x_min, y_min, x_max, y_max] format using Shapely.\n    \n    Parameters:\n    - boxes1 (np.ndarray): Shape (N, 4)\n    - boxes2 (np.ndarray): Shape (M, 4)\n    \n    Returns:\n    - np.ndarray: IoU matrix of shape (N, M)\n    \"\"\"\n    boxes1 = np.array(boxes1)\n    boxes2 = np.array(boxes2)\n    if boxes1.ndim == 1:\n        boxes1 = boxes1.reshape(1, -1)\n    if boxes2.ndim == 1:\n        boxes2 = boxes2.reshape(1, -1)\n    \n    N, M = boxes1.shape[0], boxes2.shape[0]\n    \n    area1 = (boxes1[:, 2] - boxes1[:, 0]) * (boxes1[:, 3] - boxes1[:, 1])\n    area2 = (boxes2[:, 2] - boxes2[:, 0]) * (boxes2[:, 3] - boxes2[:, 1])\n    \n    boxes1_shapely = [box(b[0], b[1], b[2], b[3]) for b in boxes1]\n    boxes2_shapely = [box(b[0], b[1], b[2], b[3]) for b in boxes2]\n    \n    iou_matrix = np.zeros((N, M))\n    for i in range(N):\n        for j in range(M):\n            intersection = boxes1_shapely[i].intersection(boxes2_shapely[j]).area\n            union = area1[i] + area2[j] - intersection\n            iou_matrix[i, j] = intersection / union if union &gt; 0 else 0.0\n    \n    return iou_matrix\n\n\ndef compute_pr_batch(predictions, ground_truths, iou_threshold=0.5):\n    if not predictions:\n        return np.array([]), np.array([])\n    \n    pred_boxes = np.array(predictions)\n    gt_boxes = np.array(ground_truths)\n    \n    iou_matrix = compute_iou_shapely_batch(pred_boxes, gt_boxes)\n    \n    tp = np.zeros(len(predictions))\n    fp = np.zeros(len(predictions))\n    gt_matched = set()\n    \n    # Match predictions in order of appearance (no confidence sorting)\n    for pred_idx in range(len(predictions)):\n        best_iou_idx = np.argmax(iou_matrix[pred_idx])\n        best_iou = iou_matrix[pred_idx, best_iou_idx]\n        if best_iou &gt;= iou_threshold and best_iou_idx not in gt_matched:\n            tp[pred_idx] = 1\n            gt_matched.add(best_iou_idx)\n        else:\n            fp[pred_idx] = 1\n    \n    tp_cumsum = np.cumsum(tp)\n    fp_cumsum = np.cumsum(fp)\n    precision = tp_cumsum / (tp_cumsum + fp_cumsum + 1e-10)\n    recall = tp_cumsum / (len(ground_truths) + 1e-10)\n    return precision, recall\n\n\ndef compute_ap_voc(predictions, ground_truths, iou_threshold=0.5):\n    precision, recall = compute_pr_batch(predictions, ground_truths, iou_threshold)\n    if precision.size == 0:\n        return 0.0\n    recall_levels = np.linspace(0, 1, 11)\n    prec_at_recall = np.zeros(len(recall_levels))\n    for i, r in enumerate(recall_levels):\n        valid_precisions = [precision[j] for j in range(len(recall)) if recall[j] &gt;= r]\n        prec_at_recall[i] = max(valid_precisions) if valid_precisions else 0.0\n    return np.mean(prec_at_recall)\n\ndef compute_ap_coco(predictions, ground_truths, iou_threshold=0.5):\n    precision, recall = compute_pr_batch(predictions, ground_truths, iou_threshold)\n    if precision.size == 0:\n        return 0.0\n    recall_levels = np.linspace(0, 1, 101)\n    precision_levels = np.zeros_like(recall_levels)\n    for r, p in zip(recall[::-1], precision[::-1]):\n        precision_levels[recall_levels &lt;= r] = p\n    return (1 / 101 * precision_levels).sum()\n\ndef compute_ap_auc(predictions, ground_truths, iou_threshold=0.5):\n    precision, recall = compute_pr_batch(predictions, ground_truths, iou_threshold)\n    if precision.size == 0:\n        return 0.0\n    return np.trapz(precision, recall)\n\n\ndef generate_random_boxes(n_images=10, img_size=100, box_size=20, n_boxes=10):\n    images_data = []\n    for _ in range(n_images):\n        gt_boxes = []\n        for _ in range(n_boxes):\n            x_min = random.randint(0, img_size - box_size)\n            y_min = random.randint(0, img_size - box_size)\n            gt_boxes.append([x_min, y_min, x_min + box_size, y_min + box_size])\n        \n        pred_boxes = []\n        for gt in gt_boxes[:int(n_boxes * 0.8)]:  # 80% overlap\n            offset = random.randint(-5, 5)\n            pred_boxes.append([gt[0] + offset, gt[1] + offset, gt[2] + offset, gt[3] + offset])\n        for _ in range(n_boxes - len(pred_boxes)):  # Remaining as FPs\n            x_min = random.randint(0, img_size - box_size)\n            y_min = random.randint(0, img_size - box_size)\n            pred_boxes.append([x_min, y_min, x_min + box_size, y_min + box_size])\n        \n        images_data.append({\"gt\": gt_boxes, \"pred\": pred_boxes})\n    return images_data\n\n\ndef compute_ap50_images(images_data, iou_threshold=0.5):\n    ap_voc_scores = []\n    ap_coco_scores = []\n    ap_auc_scores = []\n    \n    for img_data in images_data:\n        gt = img_data[\"gt\"]\n        pred = img_data[\"pred\"]\n        \n        ap_voc = compute_ap_voc(pred, gt, iou_threshold)\n        ap_coco = compute_ap_coco(pred, gt, iou_threshold)\n        ap_auc = compute_ap_auc(pred, gt, iou_threshold)\n        \n        ap_voc_scores.append(ap_voc)\n        ap_coco_scores.append(ap_coco)\n        ap_auc_scores.append(ap_auc)\n    \n    ap50_voc = np.mean(ap_voc_scores)\n    ap50_coco = np.mean(ap_coco_scores)\n    ap50_auc = np.mean(ap_auc_scores)\n    \n    return ap50_voc, ap50_coco, ap50_auc\n\n\ndef plot_boxes(images_data, img_size=100):\n    fig, axes = plt.subplots(2, 5, figsize=(20, 8))\n    axes = axes.flatten()\n    \n    for i, (img_data, ax) in enumerate(zip(images_data, axes)):\n        gt_boxes = img_data[\"gt\"]\n        pred_boxes = img_data[\"pred\"]\n        \n        for gt in gt_boxes:\n            x, y, x_max, y_max = gt\n            rect = Rectangle((x, y), x_max - x, y_max - y, linewidth=2, edgecolor='g', facecolor='none')\n            ax.add_patch(rect)\n            ax.text(x, y - 2, 'GT', color='g', fontsize=8, ha='left', va='bottom')\n        \n        for pred in pred_boxes:\n            x, y, x_max, y_max = pred\n            rect = Rectangle((x, y), x_max - x, y_max - y, linewidth=2, edgecolor='r', facecolor='none')\n            ax.add_patch(rect)\n            ax.text(x, y - 2, 'Pred', color='r', fontsize=8, ha='left', va='bottom')\n        \n        ax.set_xlim(0, img_size)\n        ax.set_ylim(0, img_size)\n        ax.set_title(f'Image {i+1}')\n        ax.set_aspect('equal')\n    \n    plt.tight_layout()\n    plt.show()\n\n\nimages_data = generate_random_boxes(n_images=10, img_size=100, box_size=20, n_boxes=10)\nap50_voc, ap50_coco, ap50_auc = compute_ap50_images(images_data, iou_threshold=0.5)\n\nprint(f\"AP50 (VOC 11-point): {ap50_voc:.4f}\")\nprint(f\"AP50 (COCO 101-point): {ap50_coco:.4f}\")\nprint(f\"AP50 (AUC): {ap50_auc:.4f}\")\n\nplot_boxes(images_data, img_size=100)\n\nAP50 (VOC 11-point): 0.3409\nAP50 (COCO 101-point): 0.3317\nAP50 (AUC): 0.2619"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AI for Social Good",
    "section": "",
    "text": "Data Exploration and Understanding\n\n\n\nHrriday Ruparel\n\n\nFeb 24, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImplementing Average Precision AP50\n\n\n\nPrathmesh Maharshi\n\n\nFeb 24, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDataset Split & Exploration\n\n\n\nGuntas Singh Saran\n\n\nFeb 13, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYOLO Object Detection Tutorial\n\n\n\nZeel Patel\n\n\nFeb 7, 2025\n\n\n\n\n\n\n\n\nNo matching items"
  }
]